# ВЕЧНЫЙ ДВИГАТЕЛЬ
## Документ 03: Архитектура системы и техническое проектирование

---

# ЧАСТЬ I: ФИЛОСОФИЯ АРХИТЕКТУРЫ

## Глава 1: Принципы автономного проектирования

### 1.1 Основные архитектурные постулаты

Вечный Двигатель построен на пяти неуклонных принципах:

**ПОСТУЛАТ 1: ДЕЦЕНТРАЛИЗОВАННЫЙ ИНТЕЛЛЕКТ**
Нет единой точки отказа. Система распределяет принятие решений между четырьмя независимыми движками. Если один выходит из строя, три продолжают работу. Если три испытывают трудности, один поддерживает работу.

**ПОСТУЛАТ 2: МНОГОУРОВНЕВАЯ ЗАЩИТА**
Управление рисками — это не модуль, а фундамент. Каждый компонент предполагает, что другие могут выйти из строя, и защищается соответствующим образом.

**ПОСТУЛАТ 3: МЕХАНИЧЕСКОЕ ИСПОЛНЕНИЕ**
Нет усмотрения. Нет субъективных решений. Нет "в этот раз будет иначе". Каждое действие основано на правилах и протестировано на исторических данных.

**ПОСТУЛАТ 4: ЭВОЛЮЦИОННАДАПТАЦИЯ**
Система отслеживает собственную производительность и корректируется. Стратегии, которые теряют эффективность, заменяются. Новые возможности интегрируются.

**ПОСТУЛАТ 5: НАБЛЮДАЕМОСТЬ**
Каждое решение, каждая сделка, каждое "сердцебиение" регистрируется, отслеживается и поддается аудиту. Ничего не происходит в темноте.

### 1.2 Многоуровневая архитектура

```
┌─────────────────────────────────────────────────────────────────┐
│                    УРОВЕНЬ 5: ПРЕДСТАВЛЕНИЕ                      │
│         (Дашборды, Оповещения, Отчеты, API-потребители)         │
├─────────────────────────────────────────────────────────────────┤
│                    УРОВЕНЬ 4: УПРАВЛЕНИЕ                         │
│    (Аварийные выключатели, Политики, Ручное управление)         │
├─────────────────────────────────────────────────────────────────┤
│                    УРОВЕНЬ 3: ОРКЕСТРАЦИЯ                        │
│    (Распределение капитала, Ребалансировка, Ротация стратегий)  │
├─────────────────────────────────────────────────────────────────┤
│                    УРОВЕНЬ 2: ИСПОЛНЕНИЕ                         │
│    (Управление ордерами, Отслеживание позиций, Риск-контроли)   │
├─────────────────────────────────────────────────────────────────┤
│                    УРОВЕНЬ 1: ИНФРАСТРУКТУРА                     │
│    (Интеграция с биржей, Потоки данных, Управление состоянием)  │
└─────────────────────────────────────────────────────────────────┘
```

**Ключевое проектное решение:**  
Каждый уровень изолирован и взаимодействует через четко определенные интерфейсы. Сбой на Уровне 1 (недоступность API биржи) активирует Уровень 4 (аварийный выключатель), но не повреждает Уровень 3 (состояние оркестрации).

---

# ЧАСТЬ II: ЧЕТЫРЕ ДВИГАТЕЛЯ

## Глава 2: Двигатель 1 - CORE-HODL (Сохранение капитала и рост)

### 2.1 Назначение и философия

**Миссия:** Обеспечить фундамент долгосрочного накопления богатства через систематическое накопление двух доминирующих криптоактивов.

**Базовое убеждение:** Биткоин и Эфириум представляют "цифровое золото" и "цифровую нефть" 21 века. На горизонте 10-20 лет спотовое владение превосходит 95% активных стратегий.

**Отличительная черта:** Это не пассивное удержание. Это **активная ребалансировка**, которая извлекает премию волатильности при сохранении базовой экспозиции.

### 2.2 Технические спецификации

**Распределение активов:**
```yaml
CORE-HODL:
  целевое_распределение:
    BTC: 40%  # 2/3 двигателя (цифровое золото)
    ETH: 20%  # 1/3 двигателя (цифровая нефть)
  общий_вес_портфеля: 60%
  
  ребалансировка:
    частота: ежеквартально
    порог_триггера: 10%  # Отклонение от цели
    метод: порог_с_резервным_календарным
    
  исполнение:
    основной_рынок: спот
    вторичный_рынок: нет  # Без деривативов
    тип_ордера: limit_maker  # Минимизация комиссий
    
  оптимизация_доходности:
    eth_staking: включен
    платформа_стейкинга: bybit_earn
    минимальный_порог_доходности: 2.0%
```

**Алгоритм ребалансировки:**

```python
def rebalance_core_hodl(текущие_позиции, целевое_распределение):
    """
    Ежеквартальная ребалансировка с пороговым триггером
    """
    дрейф = рассчитать_дрейф_распределения(текущие_позиции, целевое_распределение)
    
    # Проверка календарного триггера (ежеквартально)
    if конец_квартала() or abs(дрейф) > ПОРОГ_РЕБАЛАНСИРОВКИ:
        перекупленные_активы = получить_перекупленные_активы(текущие_позиции)
        недокупленные_активы = получить_недокупленные_активы(текущие_позиции)
        
        # Продавать растущие, покупать падающие
        for актив in перекупленные_активы:
            сумма_продажи = рассчитать_избыточную_позицию(актив, целевое_распределение)
            разместить_лимитный_продажу(актив, сумма_продажи, цена=лучший_бид)
            
        for актив in недокупленные_активы:
            сумма_покупки = рассчитать_дефицитную_позицию(актив, целевое_распределение)
            разместить_лимитный_покупку(актив, сумма_покупки, цена=лучший_аск)
            
        записать_событие_ребалансировки(дрейф, выполненные_сделки)
```

### 2.3 Машина состояний

```
[ИНИЦИАЛИЗАЦИЯ] → [НАКОПЛЕНИЕ] → [РЕБАЛАНСИРОВКА] → [ОПТИМИЗАЦИЯ_EARN] → [НАКОПЛЕНИЕ]
      ↑                                                                      ↓
      └──────────────────────────────────────────────────────────────────────┘
```

**Состояния:**
- **ИНИЦИАЛИЗАЦИЯ**: Наращивание позиций до целевого распределения через DCA
- **НАКОПЛЕНИЕ**: Удержание позиций, мониторинг дрейфа
- **РЕБАЛАНСИРОВКА**: Исполнение продажа-высоко/покупка-низко при достижении порога
- **ОПТИМИЗАЦИЯ_EARN**: Перемещение свободного ETH в стейкинг в стабильные периоды

### 2.4 Контроль рисков

**Лимиты позиций:**
- Максимум одного актива: 45% (предотвращение концентрации)
- Минимальный кэш-буфер: 5% (аварийная ликвидность)

**Аварийные выключатели:**
- Если актив падает >70% от ATH: Приостановить ребалансировку (не продавать на дне)
- Если обнаружены проблемы с выводом с биржи: Остановить всю активность, оповестить оператора

**Метрики мониторинга:**
- Дрейф распределения (цель: <10%)
- Частота ребалансировки (цель: ежеквартально ± 2 недели)
- Доходность стейкинга vs. упущенная выгода

---

## Глава 3: Двигатель 2 - TREND (Генерация кризисной альфы)

### 3.1 Назначение и философия

**Миссия:** Захват направленных трендов на крипторынках с обеспечением положительной доходности во время крахов (кризисная альфа).

**Базовое убеждение:** Крипта демонстрирует сильную персистентность моментума из-за поведенческих искажений (стадное поведение, FOMO, паника). Следование за трендом использует эти предсказуемые паттерны.

**Отличительная черта:** В отличие от buy-and-hold, этот движет выходит во время медвежьих рынков, сохраняя капитал для повторного развертывания по более низким ценам.

### 3.2 Технические спецификации

**Параметры стратегии:**
```yaml
TREND:
  рынок: перпетуальные_фьючерсы
  активы:
    - BTC-PERP
    - ETH-PERP
    
  индикаторы:
    долгосрочная_ма: 200_period_sma
    среднесрочная_ма: 50_period_sma
    сила_тренда: adx_14
    волатильность: atr_14
    
  правила_входа:
    long:
      - цена > 200_sma
      - 50_sma > 200_sma
      - adx > 25  # Сильный тренд
    short:
      - цена < 200_sma
      - 50_sma < 200_sma
      - adx > 25
      
  правила_выхода:
    long_exit: цена_закрывается_ниже_200_sma
    short_exit: цена_закрывается_выше_200_sma
    trailing_stop: 3x_atr
    
  размер_позиции:
    риск_на_сделку: 1.0%  # Субсчета
    макс_позиция: 50%     # Субсчета на актив
    макс_плечо: 2x
    
  общий_вес_портфеля: 20%
  разделение_субсчета:
    TREND-1: 15%  # Основные параметры тренда
    TREND-2: 5%   # Альтернативные параметры (диверсификация)
```

### 3.3 Алгоритм двойного моментума

```python
class TrendEngine:
    def __init__(self):
        self.fast_ma = 50
        self.slow_ma = 200
        self.adx_threshold = 25
        self.atr_multiplier = 3.0
        
    def analyze_market(self, ohlcv_data):
        """
        Ежедневный анализ рынка
        """
        close = ohlcv_data['close']
        high = ohlcv_data['high']
        low = ohlcv_data['low']
        
        # Расчет индикаторов
        sma_50 = calculate_sma(close, self.fast_ma)
        sma_200 = calculate_sma(close, self.slow_ma)
        adx = calculate_adx(high, low, close, 14)
        atr = calculate_atr(high, low, close, 14)
        
        # Определение режима
        if close[-1] > sma_200[-1] and sma_50[-1] > sma_200[-1] and adx[-1] > self.adx_threshold:
            return Signal.LONG, self.calculate_position_size(atr)
        elif close[-1] < sma_200[-1] and sma_50[-1] < sma_200[-1] and adx[-1] > self.adx_threshold:
            return Signal.SHORT, self.calculate_position_size(atr)
        else:
            return Signal.FLAT, 0
            
    def calculate_position_size(self, atr, account_value):
        """
        Размер позиции на основе ATR (1% риска на сделку)
        """
        risk_amount = account_value * 0.01
        stop_distance = atr * 2  # 2x ATR стоп
        position_size = risk_amount / stop_distance
        
        # Применение ограничения плеча
        max_notional = account_value * 2  # Макс 2x плечо
        position_size = min(position_size, max_notional / current_price)
        
        return position_size
```

### 3.4 Машина состояний

```
[СКАНИРОВАНИЕ] → [СИГНАЛ_ОБНАРУЖЕН] → [ВХОД] → [В_ПОЗИЦИИ] → [ВЫХОД] → [СКАНИРОВАНИЕ]
                ↓                  ↓            ↓
           [НЕТ_СДЕЛКИ]      [СТОП_СРАБОТАЛ]  [TRAILING_STOP]
```

### 3.5 Контроль рисков

**Управление позициями:**
- Максимум 2 одновременные позиции (BTC + ETH)
- Риск на сделку: 1% субсчета (0.2% от общего портфеля)
- Плечо: Максимум 2x (буфер ликвидации >50%)

**Архитектура стоп-лоссов:**
- Жесткий стоп: 2x ATR от точки входа
- Трейлинг-стоп: 3x ATR после прибыльности
- Временной стоп: Закрыть после 30 дней независимо от P&L (предотвращение застоя)

**Аварийные выключатели:**
- Если ADX < 20 в течение 14 дней: Приостановить новые входы (нет тренда)
- Если корреляция > 0.9: Сократить размеры позиций на 50%
- Если ставка финансирования > 0.1% за 8ч: Рассмотреть закрытие (дорого держать)

---

## Глава 4: Двигатель 3 - FUNDING (Рыночно-нейтральная доходность)

### 4.1 Назначение и философия

**Миссия:** Генерация стабильной рыночно-нейтральной доходности за счет захвата премий по ставкам финансирования перпетуальных фьючерсов.

**Базовое убеждение:** Долгосрочный бычий настрой на крипторынках создает постоянный дисбаланс ставок финансирования. Дельта-нейтральные позиции собирают эту премию без направленного риска.

**Отличительная черта:** Обеспечивает положительную доходность даже на медвежьих рынках, когда другие движки испытывают трудности.

### 4.2 Технические спецификации

```yaml
FUNDING:
  стратегия: дельта_нейтральный_арбитраж_финансирования
  активы:
    - BTC
    - ETH
    - SOL
    
  структура:
    длинная_нога: спот_рынок
    короткая_нога: перпетуальные_фьючерсы
    соотношение: 1:1  # Идеальная дельта-нейтральность
    
  условия_входа:
    предсказуемая_ставка_финансирования: "> 0.01% за 8ч"  # Положительное финансирование
    последовательных_положительных_периодов: ">= 2"
    макс_длительность_позиции: 14_дней
    
  условия_выхода:
    финансирование_отрицательное: true
    премия_перп_спот: "> 2%"  # Базисный риск слишком высок
    превышено_время_удержания: 14_дней
    
  реинвестирование:
    автокапитализация: true
    коэффициент_капитализации: 0.5  # 50% реинвестировать, 50% в тактический
    
  общий_вес_портфеля: 15%
```

### 4.3 Дельта-нейтральное исполнение

```python
class FundingArbitrageEngine:
    def __init__(self):
        self.min_funding_rate = 0.0001  # 0.01% за 8ч
        self.max_hold_days = 14
        self.max_basis = 0.02  # 2% спот-перп премия
        
    def check_opportunity(self, asset):
        """
        Проверка привлекательности арбитража финансирования
        """
        funding_rate = get_predicted_funding_rate(asset)
        spot_price = get_spot_price(asset)
        perp_price = get_perp_price(asset)
        basis = (perp_price - spot_price) / spot_price
        
        if (funding_rate > self.min_funding_rate and 
            basis < self.max_basis and
            self.funding_trend_positive(asset, periods=2)):
            return True
        return False
        
    def enter_position(self, asset, notional_size):
        """
        Открытие дельта-нейтральной позиции
        """
        # Длинный спот
        spot_order = place_spot_buy(
            symbol=f"{asset}/USDT",
            notional=notional_size,
            order_type='market'
        )
        
        # Короткий перп (та же номинальная сумма)
        perp_order = place_perp_sell(
            symbol=f"{asset}-PERP",
            notional=notional_size,
            order_type='market',
            reduce_only=False
        )
        
        # Мониторинг выплат финансирования
        self.schedule_funding_collection(asset, position_id)
        
    def on_funding_payment(self, asset, amount):
        """
        Обработка выплаты финансирования (получается каждые 8 часов)
        """
        if amount > 0:
            # Получено финансирование — прибыльно
            self.profits += amount
            
            # Капитализировать 50%
            compound_amount = amount * 0.5
            self.increase_position_size(asset, compound_amount)
            
            # Перевести 50% в тактический
            tactical_amount = amount * 0.5
            self.transfer_to_subaccount('TACTICAL', tactical_amount)
```

### 4.4 Машина состояний

```
[МОНИТОРИНГ] → [ВОЗМОЖНОСТЬ_ОБНАРУЖЕНА] → [ВХОД] → [СБОР_ФИНАНСИРОВАНИЯ] → [ВЫХОД]
                                                      ↓
                                               [МАКС_ДНЕЙ_УДЕРЖАНИЯ]
                                                      ↓
                                               [ФИНАНСИРОВАНИЕ_ОТРИЦАТЕЛЬНОЕ]
```

### 4.5 Контроль рисков

**Управление базисным риском:**
- Если премия спот-перп превышает 2%: Закрыть позицию (арбитраж разрушен)
- Мониторинг тренда ставки финансирования: Выход при повороте в отрицательное

**Ограничения ликвидности:**
- Максимальная позиция: 5% капитала движка на актив
- Приоритет BTC/ETH (наибольшая ликвидность)

**Аварийные выключатели:**
- Если финансирование отрицательное в течение 3 последовательных периодов: Закрыть ВСЕ позиции
- Если обнаружено истощение страхового фонда: Аварийный выход

---

## Глава 5: Двигатель 4 - TACTICAL (Развертывание в экстремальных условиях)

### 5.1 Назначение и философия

**Миссия:** Использование поколенческих возможностей для покупки во время крахов рынка путем развертывания резервного капитала, когда другие паникуют.

**Базовое убеждение:** Крипторынки демонстрируют циклическое поведение с просадками 70-85% каждые 4 года. Покупка этих крахов исторически дает доходность 300-1000%.

**Отличительная черта:** Этот движет не торгует регулярно — он терпеливо ждет экстремального страха, затем наносит решительный удар.

### 5.2 Технические спецификации

```yaml
TACTICAL:
  назначение: развертывание_в_экстремальных_возможностях
  начальное_распределение: 5%  # От общего портфеля
  
  условия_триггера:
    просадка_btc_от_ath:
      уровень_1: -50%  # Развернуть 50% тактических наличных
      уровень_2: -70%  # Развернуть оставшиеся 50%
    индекс_страха_жадности:
      экстремальный_страх: < 20
    ставки_финансирования:
      глубоко_отрицательные: "< -0.05% в течение 3+ дней"
    крипто_эквивалент_vix:
      экстремальная_волатильность: "> 80"
      
  правила_развертывания:
    основной_актив: BTC  # 80% развертывания
    вторичный_актив: ETH  # 20% развертывания
    исполнение: немедленные_рыночные_ордера
    
  правила_выхода:
    целевая_прибыль: 100%  # Удвоить начальное развертывание
    лимит_времени: 12_месяцев
    возврат_в_core: true  # Перевод обратно в CORE-HODL
```

### 5.3 Обнаружение возможностей

```python
class TacticalEngine:
    def __init__(self):
        self.btc_ath = 0
        self.deployment_levels = {
            'level_1': {'drawdown': -0.50, 'deploy_pct': 0.50},
            'level_2': {'drawdown': -0.70, 'deploy_pct': 0.50}
        }
        self.deployed = False
        
    def update_ath(self, current_price):
        """Отслеживание исторического максимума"""
        if current_price > self.btc_ath:
            self.btc_ath = current_price
            self.deployed = False  # Сброс после нового ATH
            
    def check_triggers(self, current_price, fear_greed, funding_rates):
        """
        Проверка условий развертывания
        """
        if self.deployed:
            return None
            
        drawdown = (current_price - self.btc_ath) / self.btc_ath
        
        # Проверка уровней просадки
        if drawdown <= self.deployment_levels['level_2']['drawdown']:
            return {
                'trigger': 'level_2_crash',
                'deploy_amount': self.get_cash_balance() * 0.50,
                'reason': f'BTC упал {drawdown:.1%} от ATH'
            }
        elif drawdown <= self.deployment_levels['level_1']['drawdown']:
            return {
                'trigger': 'level_1_crash',
                'deploy_amount': self.get_cash_balance() * 0.50,
                'reason': f'BTC упал {drawdown:.1%} от ATH'
            }
            
        # Проверка индекса страха
        if fear_greed < 20:
            return {
                'trigger': 'extreme_fear',
                'deploy_amount': self.get_cash_balance() * 0.25,
                'reason': f'Индекс страха крипты: {fear_greed}'
            }
            
        return None
        
    def deploy_capital(self, amount):
        """
        Развертывание тактических наличных в BTC/ETH
        """
        btc_amount = amount * 0.80
        eth_amount = amount * 0.20
        
        place_market_buy('BTC/USDT', btc_amount)
        place_market_buy('ETH/USDT', eth_amount)
        
        self.deployed = True
        log_deployment_event(amount, btc_amount, eth_amount)
```

### 5.4 Машина состояний

```
[НАКОПЛЕНИЕ_НАЛИЧНЫХ] → [МОНИТОРИНГ_РЫНКОВ] → [ТРИГГЕР_ОБНАРУЖЕН] → [РАЗВЕРТЫВАНИЕ]
         ↑                                                               ↓
         └────────────────────[ВОЗВРАТ_В_CORE] ← [ЦЕЛЬ_ПРИБЫЛИ_ДОСТИГНУТА]──┘
```

### 5.5 Контроль рисков

**Дисциплина развертывания:**
- Развертывать только при подтвержденных триггерах (не "кажется дешево")
- Никогда не развертывать более 50% тактических наличных в одном событии
- Ждать минимум 30 дней между развертываниями

**Дисциплина выхода:**
- Автоматический возврат в CORE-HODL после 12 месяцев
- Фиксация прибыли при 100% росте (механически, не эмоционально)
- Частичный выход при быстром достижении 50% роста

**Аварийные выключатели:**
- Если развернуто и цена падает еще 30%: Держать (не паниковать)
- Если проблемы с биржей во время развертывания: Отменить и повторить

---

# ЧАСТЬ III: ОБЩЕСИСТЕМНАЯ АРХИТЕКТУРА

## Глава 6: Уровень оркестрации

### 6.1 Двигатель распределения капитала

Уровень оркестрации динамически распределяет капитал между движками в зависимости от рыночных условий.

**Распределение по умолчанию:**
```
CORE-HODL:   60% (базовый случай)
TREND:       20% (базовый случай)
FUNDING:     15% (базовый случай)
TACTICAL:     5% (базовый случай)
```

**Динамические корректировки:**

| Рыночное условие | CORE | TREND | FUNDING | TACTICAL |
|------------------|------|-------|---------|----------|
| Сильный бык (ADX>40) | 50% | 35% | 10% | 5% |
| Медвежий рынок | 70% | 5% | 15% | 10% |
| Высокая волатильность | 55% | 15% | 25% | 5% |
| Перед халвингом (BTC) | 50% | 30% | 15% | 5% |

### 6.2 Главный контроллер

```python
class EternalEngine:
    def __init__(self):
        self.engines = {
            'core': CoreHodlEngine(),
            'trend': TrendEngine(),
            'funding': FundingArbitrageEngine(),
            'tactical': TacticalEngine()
        }
        self.risk_manager = RiskManager()
        self.orchestrator = CapitalOrchestrator()
        
    def run_daily_cycle(self):
        """
        Основной ежедневный цикл исполнения
        """
        # 1. Обновление рыночных данных
        market_data = self.fetch_market_data()
        
        # 2. Проверка рисков
        risk_status = self.risk_manager.assess_portfolio()
        if risk_status.action != 'NORMAL':
            self.execute_risk_action(risk_status)
            return
            
        # 3. Запуск каждого движка
        for name, engine in self.engines.items():
            signals = engine.analyze(market_data)
            for signal in signals:
                if self.risk_manager.approve(signal):
                    self.execute_signal(signal)
                    
        # 4. Оркестрация капитала
        rebalancing_trades = self.orchestrator.rebalance_if_needed()
        for trade in rebalancing_trades:
            self.execute_trade(trade)
            
        # 5. Логирование и отчетность
        self.log_daily_summary()
        
    def execute_signal(self, signal):
        """
        Исполнение утвержденного торгового сигнала
        """
        try:
            order = self.place_order(signal)
            self.monitor_execution(order)
        except Exception as e:
            self.handle_execution_error(e, signal)
```

### 6.3 Механика ребалансировки

**Междудвигательная ребалансировка:**

```
ЕСЛИ движок TREND вырос до 30% портфеля (с 20%):
  → Продать позиции TREND на 10%
  → Распределить: 50% в CORE, 30% в FUNDING, 20% в TACTICAL
  → Залогировать как "событие сбора волатильности"
```

**Интеграция ежемесячных взносов:**

```
ПРИ ежемесячном_депозите(сумма):
  → Определить наиболее недовложенный движок
  → Депозит направить сначала туда
  → Если все движки на цели, распределить по весам
```

## Глава 7: Архитектура данных

### 7.1 Источники данных

**Первичный: Bybit API**
- Сделки в реальном времени (WebSocket)
- Обновления стакана (WebSocket)
- Данные OHLCV (REST)
- Данные счета/позиций (REST + WebSocket)
- Прогнозы ставок финансирования (REST)

**Вторичный: Внешние**
- Индекс Страха и Жадности (alternative.me)
- Ончейн-метрики (Glassnode API)
- Социальный сентимент (LunarCrush)

### 7.2 Поток данных

```
┌─────────────────┐     ┌──────────────────┐     ┌─────────────────┐
│   Bybit API     │────▶│  Конвейер данных │────▶│  Двигатели      │
│   (Сырые данные)│     │  (Очистка)       │     │  стратегий      │
└─────────────────┘     └──────────────────┘     └─────────────────┘
                               │
                               ▼
                        ┌──────────────────┐
                        │  Time-Series DB  │
                        │  (InfluxDB)      │
                        └──────────────────┘
                               │
                               ▼
                        ┌──────────────────┐
                        │  Аналитика       │
                        │  (Дашборды)      │
                        └──────────────────┘
```

### 7.3 Управление состоянием

**Постоянное состояние (База данных):**
- Открытые позиции
- Исторические сделки
- Метрики производительности
- Параметры конфигурации

**Временное состояние (Память):**
- Текущие рыночные данные
- Отложенные ордера
- Сессионные переменные

**Протокол восстановления:**
```
ПРИ перезапуске_системы:
  1. Загрузить постоянное состояние из БД
  2. Сверка с биржей (получить текущие позиции)
  3. Выявить любые расхождения
  4. Оповестить оператора при необходимости ручного вмешательства
  5. Возобновить нормальную работу
```

## Глава 8: Уровень исполнения

### 8.1 Система управления ордерами

**Жизненный цикл ордера:**
```
[СОЗДАН] → [ПРОВЕРЕН] → [ОТПРАВЛЕН] → [ПОДТВЕРЖДЕН] → [ОТКРЫТ] → [ИСПОЛНЕН]
                                              ↓
                                         [ОТКЛОНЕН]
                                              ↓
                                         [ОТМЕНЕН]
```

**Умная маршрутизация ордеров:**
```python
def place_smart_order(signal):
    """
    Интеллектуальное исполнение ордера
    """
    if signal.urgency == 'HIGH':
        # Рыночный ордер с защитой от проскальзывания
        return place_market_order(
            symbol=signal.symbol,
            side=signal.side,
            size=signal.size,
            max_slippage=0.5  # Макс 0.5%
        )
    else:
        # Лимитный ордер по цене мейкера
        return place_limit_order(
            symbol=signal.symbol,
            side=signal.side,
            size=signal.size,
            price=calculate_maker_price(signal),
            post_only=True
        )
```

### 8.2 Обработка ошибок и логика повторных попыток

```python
class ExecutionManager:
    def __init__(self):
        self.max_retries = 3
        self.retry_delay = [1, 5, 15]  # Экспоненциальная задержка
        
    async def execute_with_retry(self, order):
        for attempt in range(self.max_retries):
            try:
                result = await self.submit_order(order)
                if result.status == 'SUCCESS':
                    return result
            except RateLimitError:
                await sleep(self.retry_delay[attempt])
                continue
            except InsufficientFundsError:
                self.alert_operator("Проблема с фондированием")
                raise
            except ExchangeError as e:
                self.log_error(e)
                if attempt < self.max_retries - 1:
                    await sleep(self.retry_delay[attempt])
                    continue
                raise
```

---

## Глава 9: Интерфейсы коммуникации

### 9.1 Внутренние API

**Коммуникация между движками:**
- Шина событий для сигналов
- Общее состояние для состава портфеля
- Асинхронный обмен сообщениями для неблокирующего исполнения

**Двигатель ↔ RiskManager:**
- Предторговая валидация
- Проверки лимитов позиций
- Мониторинг просадки

### 9.2 Внешние API

**Интеграция с Bybit:**
- V5 Unified API
- WebSocket для данных в реальном времени
- REST для исполнения ордеров
- Управление лимитами скорости

**Интеграция мониторинга:**
- Telegram-оповещения
- Email-отчеты
- API веб-дашборда

---

# ЧАСТЬ IV: АРХИТЕКТУРА РАЗВЕРТЫВАНИЯ

## Глава 10: Проектирование инфраструктуры

### 10.1 Облачная архитектура

**Провайдер:** AWS (или эквивалент)
**Регионы:** ap-southeast-1 (Сингапур) — ближайший к серверам Bybit

**Компоненты:**
```
┌─────────────────────────────────────────────────────────┐
│                    VPC (Изолированная сеть)             │
├─────────────────────────────────────────────────────────┤
│  ┌──────────────┐  ┌──────────────┐  ┌──────────────┐  │
│  │  ECS/Fargate │  │   RDS        │  │  ElastiCache │  │
│  │  (Торговый   │  │  (PostgreSQL)│  │  (Redis)     │  │
│  │   движок)    │  │              │  │              │  │
│  └──────────────┘  └──────────────┘  └──────────────┘  │
├─────────────────────────────────────────────────────────┤
│  CloudWatch (Мониторинг и логирование)                  │
│  Secrets Manager (API-ключи)                            │
│  KMS (Шифрование)                                       │
└─────────────────────────────────────────────────────────┘
```

### 10.2 Высокая доступность

**Избыточность:**
- Развертывание в нескольких зонах доступности
- Автомасштабирование при всплесках нагрузки
- Резервное копирование базы данных каждые 6 часов
- Горячий резерв в вторичном регионе

**Восстановление после сбоев:**
- RPO (Целевая точка восстановления): 1 час
- RTO (Целевое время восстановления): 4 часа
- Автоматизированные процедуры отказоустойчивости

### 10.3 Архитектура безопасности

**Уровни защиты:**
1. **Сеть**: Изоляция VPC, группы безопасности, отсутствие публичного IP
2. **Приложение**: Валидация входных данных, ограничение скорости, подпись запросов
3. **Данные**: Шифрование при хранении (AES-256) и передаче (TLS 1.3)
4. **Секреты**: AWS Secrets Manager, автоматическая ротация
5. **Доступ**: IAM-роли, отсутствие жестко закодированных учетных данных

**Управление API-ключами:**
- Ключи только для чтения для мониторинга
- Ключи с ограничением торговли на субсчет
- Белый список IP
- Регулярная ротация (ежеквартально)

---

# Глава 11: Соображения масштабируемости

### 11.1 Горизонтальное масштабирование

**Стратегия:**
- Экземпляры движков без состояния
- Общая база данных для сохранения данных
- Балансировщик нагрузки для API-запросов
- Очередь сообщений для потока ордеров

**Мощность:**
- Текущая: Обработка портфелей $100K-$1M
- Масштабированная: Может обрабатывать $100M+ без изменений архитектуры

### 11.2 Оптимизация производительности

**Снижение задержек:**
- Совместное размещение в Сингапуре (рядом с Bybit)
- WebSocket-соединения для данных в реальном времени
- Пул соединений
- Асинхронный I/O повсюду

**Пропускная способность:**
- Цель: 100 ордеров/секунду устойчиво
- Всплеск: 1000 ордеров/секунду

---

# ЗАКЛЮЧЕНИЕ

Архитектура Вечного Двигателя спроектирована для **десятилетий автономной работы**.

**Ключевые проектные решения:**
1. **Четыре движка** обеспечивают диверсификацию и покрытие различных режимов
2. **Изоляция субсчетов** предотвращает катастрофическое заражение
3. **Многоуровневая архитектура** гарантирует сдерживание сбоев
4. **Механическое исполнение** устраняет эмоции и усмотрение
5. **Комплексный мониторинг** обеспечивает наблюдаемость

**Технические спецификации:**
- **Языки**: Python (стратегии), Go (исполнение), SQL (данные)
- **Инфраструктура**: Облачная AWS
- **База данных**: PostgreSQL (реляционная), InfluxDB (time-series)
- **Мониторинг**: CloudWatch, Grafana, PagerDuty
- **Безопасность**: Многоуровневая защита, zero-trust

Это не торговый бот. Это **институт накопления капитала**, реализованный в коде.

---

*Следующий документ: [04-trading-strategies.md](./04-trading-strategies.md) - Детальные спецификации стратегий и параметры*
